#include <iostream>
class Point{
public:
    //如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做
    //bin只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有
    // 一个这样的无参构造函数，则需要自己显示地写出来
    Point(void);
    //重载构造函数，一个参数的构造函数
    ///需要注意的一点是，这个其实就是一般的构造函数，但是对于出现这种单参数的构造函数，C++会默认将
    //参数对应的类型转换为该类类型，有时候这种隐私的转换是我们所不想要的，所以需要使用explicit来限制这种转换。
    Point(double m);
    //两个参数的构造函数
    Point(int m, int n);
    //拷贝构造函数
    //复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在
    //函数中会将已存在对象的数据成员的值复制一份到新创建的对象中
    //若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，
    //由系统默认创建该复制构造函数会存在风险，具体原因请查询 有关 “浅拷贝” 、“深拷贝”的文章论述
    Point(const Point &c);
    //等号运算符重载(赋值构造函数)
    // 注意，这个类似复制构造函数，将=右边的本类对象的值复制给等号左边的对象，它不属于构造函数，
    // 等号左右两边的对象必须已经被创建
    // 若没有显示的写=运算符重载，则系统也会创建一个默认的=运算符重载，只做一些基本的拷贝工作
    Point &operator = (const Point &re);
    //析构函数
    ~Point();
private:
    int x, y;
};

//依次初始化
Point::Point(){
    std::cout<<"默认构造函数"<<std::endl;
};
Point::Point(double m){
    std::cout<<"类型转换（一个参数的构造函数）"<<std::endl;
    this->x = m;
    this->y = 0.0;
}
Point::Point(int m, int n){
    std::cout<<"两个参数的构造函数"<<std::endl;
    x += m;
    y += n;
}
Point::Point(const Point &c){
    std::cout<<"拷贝构造函数"<<std::endl;
    this->x = c.x;
    this->y = c.y;
}
Point & Point::operator=(const Point &re){
    std::cout<<"赋值运算符重载"<<std::endl;
    // 首先检测等号右边的是否就是左边的对象本身，若是本对象本身,则直接返回
    if(this == &re){
        return *this;
    }
    this->x = re.x;
    this->y = re.y;
    // 把等号左边的对象再次传出
    // 目的是为了支持连等 eg:    a=b=c 系统首先运行 b=c
    // 然后运行 a= ( b=c的返回值,这里应该是复制c值后的b对象)    

    return *this;
}
Point::~Point(){
    std::cout<<"析构函数"<<std::endl;
}

int main(void)
{
    // 调用了无参构造函数，数据成员初值被赋为0.0
    Point C1, C2;
    // 调用一般构造函数，数据成员初值被赋为指定值
    Point C3(1, 2);
    //也可以下面这种方式
    Point C4 = Point(1, 2);
    //把c3的数据成员的值赋值给c1
    //由于c1已经事先被创建，故此处不会调用任何构造函数
    //只会调用 = 号运算符重载函数
   
    C1 = C3;
    //调用类型转换构造函数
    //调用类型转换构造函数
    Point C5 = 5.2;
    // 调用拷贝构造函数( 有下面两种调用方式)
    Point C6(C3);
    Point C7 = C4;
    // 注意和 = 运算符重载区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c3、C4
    //这一点特别重要，这儿是初始化，不是赋值。其实这儿就涉及了C++中的两种初始化的方式：复制初始化和赋值初始化。其中C6采用的是
    //复制初始化，而C7采用的是赋值初始化，这两种方式都是要调用拷贝构造函数的。
}
/*预测输出结果：
 * 构造函数
 * 构造函数
 * 两个参数的构造函数
 * 两个参数的构造函数
 * 赋值运算符重载
 * 转换函数（一个参数的构造函数）
 * ///////////////////////一个参数的拷贝构造函数并不会调用等号运算符重载：：赋值运算符重载
 * 拷贝构造函数
 * 拷贝构造函数
 * 若干析构*/

//运行结果

/* 默认构造函数 */
/* 默认构造函数 */
/* 两个参数的构造函数 */
/* 两个参数的构造函数 */
/* 赋值运算符重载 */
/* 类型转换（一个参数的构造函数） */
/* 拷贝构造函数 */
/* 拷贝构造函数 */
/* 析构函数 */
/* 析构函数 */
/* 析构函数 */
/* 析构函数 */
/* 析构函数 */
/* 析构函数 */
/* 析构函数 */

